<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Packer Pro - å½»åº•ä¿®å¤ç‰ˆ</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
    }

    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 2.2rem;
    }

    .subtitle {
      color: #666;
      font-size: 1.1rem;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    label {
      font-weight: bold;
      color: #333;
    }

    input, select {
      padding: 8px 12px;
      border: 2px solid #667eea;
      border-radius: 6px;
      width: 120px;
    }

    button {
      padding: 10px 20px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
    }

    .results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(650px, 1fr));
      gap: 25px;
      margin-top: 20px;
    }

    .group-result {
      background: white;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      transition: transform 0.3s ease;
    }

    .group-result:hover {
      transform: translateY(-5px);
    }

    .group-header {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .group-content {
      padding: 20px;
    }

    .visualization {
      position: relative;
      height: 400px;
      border: 2px solid #667eea;
      border-radius: 8px;
      margin-bottom: 15px;
      background: #f8f9ff;
      overflow: hidden;
    }

    .container-boundary {
      position: absolute;
      width: 600px;
      height: 100%;
      border: 2px dashed #e74c3c;
      background: rgba(102, 126, 234, 0.05);
    }

    .image-item {
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      border-radius: 4px;
    }

    .image-item:hover {
      transform: scale(1.05);
      z-index: 10;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .image-number {
      background: rgba(0, 0, 0, 0.7);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
    }

    .rotated-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #e74c3c;
      color: white;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    .stats {
      background: #f8f9ff;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 4px 0;
      border-bottom: 1px dashed #ddd;
    }

    .stat-row:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .color-0 { background: linear-gradient(135deg, #ff6b6b, #ee5a24); }
    .color-1 { background: linear-gradient(135deg, #4ecdc4, #44a08d); }
    .color-2 { background: linear-gradient(135deg, #45b7d1, #96c93d); }
    .color-3 { background: linear-gradient(135deg, #f093fb, #f5576c); }
    .color-4 { background: linear-gradient(135deg, #4facfe, #00f2fe); }
    .color-5 { background: linear-gradient(135deg, #fad0c4, #ffd1ff); }
    .color-6 { background: linear-gradient(135deg, #a8edea, #fed6e3); }
    .color-7 { background: linear-gradient(135deg, #ff9a9e, #fecfef); }

    .algorithm-info {
      background: #e8f4fd;
      padding: 12px;
      border-radius: 8px;
      margin-top: 15px;
      font-size: 13px;
      border-left: 4px solid #667eea;
    }

    .fix-note {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 8px;
      font-size: 13px;
    }

    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .comparison-item {
      background: #f8f9ff;
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #667eea;
    }

    .comparison-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #667eea;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ¨ å½»åº•ä¿®å¤ç‰ˆå›¾ç‰‡æ’åˆ—ç®—æ³•</h1>
      <p class="subtitle">ä¸“é—¨è§£å†³ç»†é•¿å›¾ç‰‡çš„ç©ºé—´æµªè´¹é—®é¢˜</p>

      <div class="controls">
        <div class="control-group">
          <label>é—´è· (px):</label>
          <input type="number" id="gapInput" min="0" max="20" value="5" />
        </div>
        <button id="optimizeBtn">ğŸš€ å¼€å§‹ä¼˜åŒ–</button>
      </div>
    </div>

    <div class="results" id="resultsContainer">
      <!-- ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
    </div>
  </div>

  <script>
    // å›¾ç‰‡æ•°æ®
    const imageGroups = [
      {
        id: 1,
        name: 'å›¾ç»„1 - é—®é¢˜æ¡ˆä¾‹',
        images: [
          { w: 400.0, h: 84.4 },
          { w: 32.3, h: 320.0 },
          { w: 32.3, h: 320.0 },
          { w: 102.4, h: 140.0 },
          { w: 140.0, h: 102.4 },
        ],
      },
      {
        id: 2,
        name: 'å›¾ç»„2',
        images: [
          { w: 405.3, h: 200.0 },
          { w: 400.8, h: 200.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
          { w: 55.7, h: 50.0 },
        ],
      },
      {
        id: 3,
        name: 'å›¾ç»„3',
        images: [
          { w: 80.0, h: 33.8 },
          { w: 80.0, h: 33.8 },
          { w: 80.0, h: 33.7 },
          { w: 80.0, h: 33.7 },
          { w: 80.0, h: 33.7 },
          { w: 55.1, h: 55.0 },
          { w: 55.1, h: 55.0 },
        ],
      },
      {
        id: 4,
        name: 'å›¾ç»„4',
        images: [
          { w: 280.0, h: 149.7 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
          { w: 51.1, h: 45.0 },
        ],
      },
      {
        id: 5,
        name: 'å›¾ç»„5',
        images: [
          { w: 280.0, h: 28.7 },
          { w: 280.0, h: 28.7 },
          { w: 75.0, h: 50.2 },
          { w: 75.0, h: 50.2 },
          { w: 75.0, h: 50.2 },
          { w: 75.0, h: 50.2 },
          { w: 75.0, h: 50.2 },
          { w: 75.0, h: 50.2 },
        ],
      },
    ]

    const CONTAINER_WIDTH = 600

    // æ ¸å¿ƒä¿®å¤ç®—æ³•ï¼šå‚ç›´ç©ºé—´å¡«å……ä¼˜å…ˆç®—æ³•
    function fixedVerticalPackingAlgorithm(images, gap) {
      console.log('å¼€å§‹å‚ç›´ç©ºé—´å¡«å……ç®—æ³•...')
      
      // åˆ†æå›¾ç‰‡ç‰¹å¾
      const items = images.map((img, idx) => {
        const aspectRatio = img.w / img.h
        const area = img.w * img.h
        
        return {
          originalIndex: idx,
          normal: { w: img.w, h: img.h, rotated: false },
          rotated: { w: img.h, h: img.w, rotated: true },
          aspectRatio,
          area,
          isVeryTall: img.h > img.w * 3, // å¾ˆé«˜çš„å›¾ç‰‡
          isVeryWide: img.w > img.h * 3, // å¾ˆå®½çš„å›¾ç‰‡
          canFitNormal: img.w <= CONTAINER_WIDTH - gap,
          canFitRotated: img.h <= CONTAINER_WIDTH - gap
        }
      })

      console.log('å›¾ç‰‡åˆ†æç»“æœ:', items)

      // ç­–ç•¥ï¼šä¼˜å…ˆå¤„ç†å¤§å›¾ç‰‡å’Œç‰¹æ®Šæ¯”ä¾‹å›¾ç‰‡
      const sortedItems = [...items].sort((a, b) => {
        // ä¼˜å…ˆçº§1ï¼šå¾ˆå®½çš„å›¾ç‰‡æ”¾æœ€å‰é¢
        if (a.isVeryWide && !b.isVeryWide) return -1
        if (!a.isVeryWide && b.isVeryWide) return 1
        
        // ä¼˜å…ˆçº§2ï¼šé¢ç§¯å¤§çš„å›¾ç‰‡
        if (Math.abs(a.area - b.area) > 1000) {
          return b.area - a.area
        }
        
        // ä¼˜å…ˆçº§3ï¼šå¾ˆé«˜çš„å›¾ç‰‡æ”¾åé¢ï¼Œä¾¿äºå¡«å……ç©ºéš™
        if (a.isVeryTall && !b.isVeryTall) return 1
        if (!a.isVeryTall && b.isVeryTall) return -1
        
        return 0
      })

      const placed = []
      const rotations = new Array(images.length).fill(false)

      for (const item of sortedItems) {
        console.log(`æ­£åœ¨å¤„ç†å›¾ç‰‡${item.originalIndex + 1}:`, item)
        
        // ç¡®å®šä½¿ç”¨å“ªä¸ªæ–¹å‘
        let bestOption = null
        
        if (item.canFitNormal && item.canFitRotated) {
          // ä¸¤ä¸ªæ–¹å‘éƒ½å¯ä»¥ï¼Œéœ€è¦æ™ºèƒ½é€‰æ‹©
          if (item.isVeryWide) {
            // å¾ˆå®½çš„å›¾ç‰‡ä¿æŒåŸæ–¹å‘
            bestOption = item.normal
          } else if (item.isVeryTall) {
            // å¾ˆé«˜çš„å›¾ç‰‡ï¼šå¦‚æœå½“å‰æœ‰åˆé€‚çš„å‚ç›´ç©ºé—´å°±ä¸æ—‹è½¬ï¼Œå¦åˆ™æ—‹è½¬
            const verticalSpaceNeeded = item.normal.h
            const hasVerticalSpace = checkVerticalSpace(placed, verticalSpaceNeeded, gap)
            bestOption = hasVerticalSpace ? item.normal : item.rotated
          } else {
            // æ™®é€šå›¾ç‰‡ï¼šé€‰æ‹©æ›´é€‚åˆå½“å‰ç©ºé—´çš„æ–¹å‘
            const normalPos = findOptimalPosition(placed, item.normal, gap)
            const rotatedPos = findOptimalPosition(placed, item.rotated, gap)
            
            if (normalPos && rotatedPos) {
              // é€‰æ‹©yåæ ‡æ›´å°çš„ä½ç½®
              bestOption = normalPos.y <= rotatedPos.y ? item.normal : item.rotated
            } else if (normalPos) {
              bestOption = item.normal
            } else if (rotatedPos) {
              bestOption = item.rotated
            }
          }
        } else if (item.canFitNormal) {
          bestOption = item.normal
        } else if (item.canFitRotated) {
          bestOption = item.rotated
        }

        if (!bestOption) {
          console.log(`å›¾ç‰‡${item.originalIndex + 1}æ— æ³•æ”¾ç½®`)
          continue
        }

        // å¯»æ‰¾æœ€ä½³ä½ç½®
        const position = findOptimalPosition(placed, bestOption, gap)
        
        if (position) {
          placed.push({
            x: position.x,
            y: position.y,
            width: bestOption.w,
            height: bestOption.h,
            originalIndex: item.originalIndex,
            rotated: bestOption.rotated,
          })
          rotations[item.originalIndex] = bestOption.rotated
          
          console.log(`å›¾ç‰‡${item.originalIndex + 1}å·²æ”¾ç½®:`, {
            x: position.x,
            y: position.y,
            width: bestOption.w,
            height: bestOption.h,
            rotated: bestOption.rotated
          })
        }
      }

      const totalHeight = placed.length > 0 
        ? Math.max(...placed.map(p => p.y + p.height)) + gap 
        : 0

      console.log('æœ€ç»ˆå¸ƒå±€ç»“æœ:', { totalHeight, placed, rotations })

      return {
        totalHeight,
        layout: placed,
        rotations,
        algorithm: 'å‚ç›´ç©ºé—´å¡«å……ç®—æ³•'
      }
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å‚ç›´ç©ºé—´
    function checkVerticalSpace(placed, neededHeight, gap) {
      if (placed.length === 0) return true
      
      const maxY = Math.max(...placed.map(p => p.y + p.height))
      const availableHeight = 400 - maxY - gap // å‡è®¾å®¹å™¨é«˜åº¦ä¸º400
      
      return availableHeight >= neededHeight + gap
    }

    // å¯»æ‰¾æœ€ä¼˜ä½ç½®ï¼ˆé‡æ–°å®ç°ï¼Œä¸“æ³¨è§£å†³ç©ºé—´æµªè´¹ï¼‰
    function findOptimalPosition(placed, item, gap) {
      if (item.w > CONTAINER_WIDTH - gap) return null

      const candidates = []

      // å€™é€‰ä½ç½®1ï¼šå·¦ä¸Šè§’
      candidates.push({ 
        x: gap, 
        y: gap, 
        score: calculatePositionScore(gap, gap, placed, item, gap)
      })

      // å€™é€‰ä½ç½®2ï¼šåœ¨ç°æœ‰å›¾ç‰‡çš„å³ä¾§å’Œä¸‹æ–¹
      for (const p of placed) {
        // å³ä¾§
        if (p.x + p.width + gap + item.w <= CONTAINER_WIDTH) {
          const x = p.x + p.width + gap
          const y = p.y
          candidates.push({
            x,
            y,
            score: calculatePositionScore(x, y, placed, item, gap)
          })
        }

        // ä¸‹æ–¹ï¼ˆå¯¹é½å·¦è¾¹ï¼‰
        const x1 = p.x
        const y1 = p.y + p.height + gap
        candidates.push({
          x: x1,
          y: y1,
          score: calculatePositionScore(x1, y1, placed, item, gap)
        })

        // ä¸‹æ–¹ï¼ˆå·¦å¯¹é½å®¹å™¨ï¼‰
        const x2 = gap
        const y2 = p.y + p.height + gap
        candidates.push({
          x: x2,
          y: y2,
          score: calculatePositionScore(x2, y2, placed, item, gap)
        })
      }

      // å€™é€‰ä½ç½®3ï¼šå¯»æ‰¾å¯ä»¥å¡«å……çš„ç©ºéš™
      const gaps = findGaps(placed, gap)
      for (const gapRect of gaps) {
        if (gapRect.width >= item.w && gapRect.height >= item.h) {
          candidates.push({
            x: gapRect.x,
            y: gapRect.y,
            score: calculatePositionScore(gapRect.x, gapRect.y, placed, item, gap) - 100 // å¡«å……ç©ºéš™ä¼˜å…ˆ
          })
        }
      }

      // è¿‡æ»¤é‡å ä½ç½®
      const validPositions = candidates.filter(pos => {
        return !isOverlapping(pos, item, placed, gap)
      })

      if (validPositions.length === 0) return null

      // é€‰æ‹©è¯„åˆ†æœ€ä½³çš„ä½ç½®
      validPositions.sort((a, b) => a.score - b.score)
      
      console.log(`å›¾ç‰‡ä½ç½®å€™é€‰:`, validPositions.slice(0, 3))
      
      return validPositions[0]
    }

    // è®¡ç®—ä½ç½®è¯„åˆ†ï¼ˆåˆ†æ•°è¶Šä½è¶Šå¥½ï¼‰
    function calculatePositionScore(x, y, placed, item, gap) {
      let score = y * 10 // åŸºç¡€åˆ†ï¼šyåæ ‡è¶Šä½è¶Šå¥½
      
      // å¥–åŠ±ï¼šé å·¦æ”¾ç½®
      score += x * 0.1
      
      // å¥–åŠ±ï¼šç´§å¯†æ”¾ç½®ï¼ˆå‡å°‘å­¤ç«‹ï¼‰
      let hasNeighbor = false
      for (const p of placed) {
        const distance = Math.abs(x - p.x) + Math.abs(y - p.y)
        if (distance < item.w + item.h) {
          hasNeighbor = true
          score -= 20 // æœ‰é‚»å±…çš„ä½ç½®æ›´å¥½
          break
        }
      }
      
      // æƒ©ç½šï¼šäº§ç”Ÿéš¾ä»¥å¡«å……çš„å°ç©ºéš™
      const wouldCreateSmallGap = checkWouldCreateSmallGap(x, y, item, placed, gap)
      if (wouldCreateSmallGap) {
        score += 50
      }
      
      return score
    }

    // æ£€æŸ¥æ˜¯å¦ä¼šäº§ç”Ÿå°ç©ºéš™
    function checkWouldCreateSmallGap(x, y, item, placed, gap) {
      // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥å³è¾¹å’Œä¸‹é¢æ˜¯å¦ä¼šç•™ä¸‹å¾ˆå°çš„ç©ºé—´
      const rightSpace = CONTAINER_WIDTH - (x + item.w + gap)
      const minGapThreshold = 50 // å°äº50pxçš„ç©ºéš™è®¤ä¸ºæ˜¯æµªè´¹
      
      return rightSpace > 0 && rightSpace < minGapThreshold
    }

    // å¯»æ‰¾å¯å¡«å……çš„ç©ºéš™
    function findGaps(placed, gap) {
      if (placed.length === 0) return []
      
      const gaps = []
      const maxY = Math.max(...placed.map(p => p.y + p.height))
      
      // ç®€åŒ–å®ç°ï¼šå¯»æ‰¾ä¸€äº›åŸºæœ¬çš„çŸ©å½¢ç©ºéš™
      for (let y = gap; y < maxY; y += 20) {
        for (let x = gap; x < CONTAINER_WIDTH - gap; x += 20) {
          const width = findMaxWidth(x, y, placed, gap)
          const height = findMaxHeight(x, y, placed, gap)
          
          if (width >= 50 && height >= 30) { // è¶³å¤Ÿå¤§çš„ç©ºéš™æ‰è€ƒè™‘
            gaps.push({ x, y, width, height })
          }
        }
      }
      
      return gaps
    }

    // åœ¨æŒ‡å®šä½ç½®å¯»æ‰¾æœ€å¤§å¯ç”¨å®½åº¦
    function findMaxWidth(startX, startY, placed, gap) {
      let maxWidth = CONTAINER_WIDTH - startX - gap
      
      for (const p of placed) {
        if (startY < p.y + p.height && startY + 30 > p.y) { // å‡è®¾æœ€å°é«˜åº¦30
          if (p.x > startX) {
            maxWidth = Math.min(maxWidth, p.x - startX - gap)
          }
        }
      }
      
      return Math.max(0, maxWidth)
    }

    // åœ¨æŒ‡å®šä½ç½®å¯»æ‰¾æœ€å¤§å¯ç”¨é«˜åº¦
    function findMaxHeight(startX, startY, placed, gap) {
      let maxHeight = 400 - startY - gap // å‡è®¾å®¹å™¨é«˜åº¦400
      
      for (const p of placed) {
        if (startX < p.x + p.width && startX + 50 > p.x) { // å‡è®¾æœ€å°å®½åº¦50
          if (p.y > startY) {
            maxHeight = Math.min(maxHeight, p.y - startY - gap)
          }
        }
      }
      
      return Math.max(0, maxHeight)
    }

    // æ£€æŸ¥é‡å 
    function isOverlapping(pos, item, placed, gap) {
      const rect1 = {
        x: pos.x,
        y: pos.y,
        width: item.w,
        height: item.h,
      }

      return placed.some(p => {
        const rect2 = {
          x: p.x,
          y: p.y,
          width: p.width,
          height: p.height,
        }

        return !(
          rect1.x + rect1.width <= rect2.x ||
          rect2.x + rect2.width <= rect1.x ||
          rect1.y + rect1.height <= rect2.y ||
          rect2.y + rect2.height <= rect1.y
        )
      })
    }

    // æ¸²æŸ“ç»“æœ
    function renderResults(groups, gap) {
      const container = document.getElementById('resultsContainer')
      container.innerHTML = ''

      groups.forEach(group => {
        const result = fixedVerticalPackingAlgorithm(group.images, gap)

        const groupDiv = document.createElement('div')
        groupDiv.className = 'group-result'

        const rotatedCount = result.rotations.filter(r => r).length
        const efficiency = result.layout.length > 0 
          ? (result.layout.reduce((sum, item) => sum + item.width * item.height, 0) /
             (CONTAINER_WIDTH * result.totalHeight) * 100).toFixed(1)
          : 0

        groupDiv.innerHTML = `
            <div class="group-header">
                <h3>${group.name}</h3>
                <span>æ€»é«˜åº¦: ${result.totalHeight.toFixed(1)}px</span>
            </div>
            <div class="group-content">
                <div class="fix-note">
                    <strong>ğŸ”§ æ ¸å¿ƒä¿®å¤:</strong> 
                    ${group.id === 1 ? 'é’ˆå¯¹å›¾ç»„1çš„ç©ºé—´æµªè´¹é—®é¢˜ï¼Œé‡‡ç”¨å‚ç›´ç©ºé—´å¡«å……ç®—æ³•ï¼Œä¼˜å…ˆå¤„ç†å¤§å›¾ç‰‡ï¼Œæ™ºèƒ½é€‰æ‹©ç»†é•¿å›¾ç‰‡çš„æ”¾ç½®æ–¹å‘' : 'ä½¿ç”¨å‚ç›´ç©ºé—´å¡«å……ç®—æ³•ä¼˜åŒ–å¸ƒå±€'}
                </div>
                <div class="visualization" id="vis-${group.id}">
                    <div class="container-boundary"></div>
                </div>
                <div class="stats">
                    <div class="stat-row">
                        <span><strong>ç®—æ³•:</strong></span>
                        <span>${result.algorithm}</span>
                    </div>
                    <div class="stat-row">
                        <span><strong>å›¾ç‰‡æ•°é‡:</strong></span>
                        <span>${group.images.length} å¼ </span>
                    </div>
                    <div class="stat-row">
                        <span><strong>æ—‹è½¬å›¾ç‰‡:</strong></span>
                        <span>${rotatedCount} å¼  (${result.rotations
                          .map((r, i) => (r ? i + 1 : ''))
                          .filter((i) => i)
                          .join(', ') || 'æ— '
                        })</span>
                    </div>
                    <div class="stat-row">
                        <span><strong>ç©ºé—´åˆ©ç”¨ç‡:</strong></span>
                        <span>${efficiency}%</span>
                    </div>
                    <div class="stat-row">
                        <span><strong>å®¹å™¨å®½åº¦:</strong></span>
                        <span>${CONTAINER_WIDTH}px</span>
                    </div>
                </div>
                <div class="algorithm-info">
                    <strong>ç®—æ³•åŸç†:</strong> 
                    1. åˆ†æå›¾ç‰‡ç‰¹å¾ï¼ˆå®½é«˜æ¯”ã€é¢ç§¯ã€ç‰¹æ®Šæ¯”ä¾‹ï¼‰<br>
                    2. ä¼˜å…ˆæ”¾ç½®å¤§å›¾ç‰‡å’Œå¾ˆå®½çš„å›¾ç‰‡å»ºç«‹åŸºç¡€å¸ƒå±€<br>
                    3. æ™ºèƒ½é€‰æ‹©ç»†é•¿å›¾ç‰‡çš„æ—‹è½¬æ–¹å‘ï¼Œé¿å…äº§ç”Ÿå¤§é¢ç§¯ç©ºç™½<br>
                    4. å¯»æ‰¾å¹¶å¡«å……å¯åˆ©ç”¨çš„ç©ºéš™åŒºåŸŸ<br>
                    5. ä½ç½®è¯„åˆ†æœºåˆ¶ç¡®ä¿ç´§å¯†æ’åˆ—
                </div>
            </div>
        `

        container.appendChild(groupDiv)
        renderImages(group, result, gap)
      })
    }

    // æ¸²æŸ“å›¾ç‰‡å¯è§†åŒ–
    function renderImages(group, result, gap) {
      const container = document.getElementById(`vis-${group.id}`)
      if (!container) return

      result.layout.forEach((item, index) => {
        const imgDiv = document.createElement('div')
        imgDiv.className = `image-item color-${item.originalIndex % 8}`
        imgDiv.style.left = `${item.x}px`
        imgDiv.style.top = `${item.y}px`
        imgDiv.style.width = `${item.width}px`
        imgDiv.style.height = `${item.height}px`

        const originalImg = group.images[item.originalIndex]
        imgDiv.title = `å›¾ç‰‡${item.originalIndex + 1}\nåŸå§‹: ${originalImg.w.toFixed(1)}Ã—${originalImg.h.toFixed(1)}\nå½“å‰: ${item.width.toFixed(1)}Ã—${item.height.toFixed(1)}\n${item.rotated ? 'å·²æ—‹è½¬90Â°' : 'æœªæ—‹è½¬'}`

        imgDiv.innerHTML = `
                    <div class="image-number">${item.originalIndex + 1}</div>
                    ${item.rotated ? '<div class="rotated-indicator">â†»</div>' : ''}
        `

        container.appendChild(imgDiv)
      })
    }

    // ä¸»æ‰§è¡Œå‡½æ•°
    async function optimize() {
      const gap = parseInt(document.getElementById('gapInput').value) || 5

      const resultsContainer = document.getElementById('resultsContainer')
      resultsContainer.innerHTML = '<div style="text-align: center; padding: 50px; color: #667eea;"><div style="font-size: 18px; margin-bottom: 10px;">ğŸ”„ æ­£åœ¨è¿è¡Œä¿®å¤ç®—æ³•...</div><div>ä¸“é—¨è§£å†³ç»†é•¿å›¾ç‰‡çš„ç©ºé—´æµªè´¹é—®é¢˜</div></div>'

      setTimeout(() => {
        renderResults(imageGroups, gap)

        console.log('=== å½»åº•ä¿®å¤ç‰ˆç®—æ³•ç»“æœ ===')
        imageGroups.forEach(group => {
          const result = fixedVerticalPackingAlgorithm(group.images, gap)
          console.log(`\n${group.name}:`)
          console.log(`ç®—æ³•: ${result.algorithm}`)
          console.log(`æ€»é«˜åº¦: ${result.totalHeight.toFixed(1)}px`)
          
          const efficiency = result.layout.length > 0 
            ? (result.layout.reduce((sum, item) => sum + item.width * item.height, 0) / (CONTAINER_WIDTH * result.totalHeight) * 100).toFixed(1)
            : 0
          console.log(`ç©ºé—´åˆ©ç”¨ç‡: ${efficiency}%`)
          console.log(`æ—‹è½¬é…ç½®: [${result.rotations.join(', ')}]`)
          
          // ç‰¹åˆ«åˆ†æå›¾ç»„1çš„æ”¹è¿›
          if (group.id === 1) {
            console.log('\n=== å›¾ç»„1è¯¦ç»†åˆ†æ ===')
            result.layout.forEach((item, idx) => {
              const original = group.images[item.originalIndex]
              console.log(`å›¾ç‰‡${item.originalIndex + 1}: åŸå§‹${original.w}Ã—${original.h} â†’ å½“å‰${item.width}Ã—${item.height} ä½ç½®(${item.x}, ${item.y}) ${item.rotated ? 'å·²æ—‹è½¬' : ''}`)
            })
            
            // è®¡ç®—ç©ºç™½åŒºåŸŸ
            const usedArea = result.layout.reduce((sum, item) => sum + item.width * item.height, 0)
            const totalArea = CONTAINER_WIDTH * result.totalHeight
            const wastedArea = totalArea - usedArea
            console.log(`æ€»é¢ç§¯: ${totalArea.toFixed(1)}, å·²ä½¿ç”¨: ${usedArea.toFixed(1)}, æµªè´¹: ${wastedArea.toFixed(1)} (${(wastedArea/totalArea*100).toFixed(1)}%)`)
          }
        })
      }, 800)
    }

    // äº‹ä»¶ç›‘å¬
    document.getElementById('optimizeBtn').addEventListener('click', optimize)

    // é¡µé¢åŠ è½½åè‡ªåŠ¨æ‰§è¡Œ
    window.addEventListener('load', () => {
      setTimeout(optimize, 200)
    })

    // æ·»åŠ ä¸€äº›è°ƒè¯•ä¿¡æ¯æ˜¾ç¤º
    function addDebugInfo() {
      console.log('=== å›¾ç‰‡æ•°æ®åˆ†æ ===')
      imageGroups.forEach(group => {
        console.log(`\n${group.name}:`)
        group.images.forEach((img, idx) => {
          const aspectRatio = (img.w / img.h).toFixed(2)
          const area = (img.w * img.h).toFixed(1)
          const isVeryTall = img.h > img.w * 3
          const isVeryWide = img.w > img.h * 3
          
          console.log(`  å›¾ç‰‡${idx + 1}: ${img.w}Ã—${img.h}, æ¯”ä¾‹${aspectRatio}, é¢ç§¯${area}, ${isVeryWide ? 'å¾ˆå®½' : isVeryTall ? 'å¾ˆé«˜' : 'æ™®é€š'}`)
        })
      })
    }

    // æ‰§è¡Œè°ƒè¯•åˆ†æ
    addDebugInfo()
  </script>
</body>

</html>
