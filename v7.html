<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Packer Pro</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
    }

    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 2.2rem;
    }

    .subtitle {
      color: #666;
      font-size: 1.1rem;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    label {
      font-weight: bold;
      color: #333;
    }

    input {
      padding: 8px 12px;
      border: 2px solid #667eea;
      border-radius: 6px;
      width: 80px;
    }

    button {
      padding: 10px 20px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
    }

    .results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(650px, 1fr));
      gap: 25px;
      margin-top: 20px;
    }

    .group-result {
      background: white;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      transition: transform 0.3s ease;
    }

    .group-result:hover {
      transform: translateY(-5px);
    }

    .group-header {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .group-content {
      padding: 20px;
    }

    .visualization {
      position: relative;
      height: 400px;
      border: 2px solid #667eea;
      border-radius: 8px;
      margin-bottom: 15px;
      background: #f8f9ff;
      overflow: hidden;
    }

    .container-boundary {
      position: absolute;
      width: 600px;
      height: 100%;
      border: 2px dashed #e74c3c;
      background: rgba(102, 126, 234, 0.05);
    }

    .image-item {
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      border-radius: 4px;
    }

    .image-item:hover {
      transform: scale(1.05);
      z-index: 10;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .image-number {
      background: rgba(0, 0, 0, 0.7);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
    }

    .rotated-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      background: #e74c3c;
      color: white;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    .stats {
      background: #f8f9ff;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 4px 0;
      border-bottom: 1px dashed #ddd;
    }

    .stat-row:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .color-0 {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
    }

    .color-1 {
      background: linear-gradient(135deg, #4ecdc4, #44a08d);
    }

    .color-2 {
      background: linear-gradient(135deg, #45b7d1, #96c93d);
    }

    .color-3 {
      background: linear-gradient(135deg, #f093fb, #f5576c);
    }

    .color-4 {
      background: linear-gradient(135deg, #4facfe, #00f2fe);
    }

    .color-5 {
      background: linear-gradient(135deg, #fad0c4, #ffd1ff);
    }

    .color-6 {
      background: linear-gradient(135deg, #a8edea, #fed6e3);
    }

    .color-7 {
      background: linear-gradient(135deg, #ff9a9e, #fecfef);
    }

    .algorithm-info {
      background: #e8f4fd;
      padding: 12px;
      border-radius: 8px;
      margin-top: 15px;
      font-size: 13px;
      border-left: 4px solid #667eea;
    }

    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 20px;
      z-index: 1000;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid white;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ¨ å›¾ç‰‡æ’åˆ—ç®—æ³•ä¼˜åŒ–å™¨</h1>
      <p class="subtitle">æ™ºèƒ½2Dè£…ç®±ç®—æ³•ï¼Œæœ€å°åŒ–æ€»é«˜åº¦ï¼Œæ”¯æŒå›¾ç‰‡æ—‹è½¬</p>

      <div class="controls">
        <div class="control-group">
          <label>é—´è· (px):</label>
          <input type="number" id="gapInput" min="0" max="20" value="5" />
        </div>
        <button id="optimizeBtn">ğŸš€ å¼€å§‹ä¼˜åŒ–</button>
      </div>
    </div>

    <div class="results" id="resultsContainer">
      <!-- ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
    </div>
  </div>

  <script>
    // å›¾ç‰‡æ•°æ®
const imageGroups = [
  {
    id: 1,
    name: 'å›¾ç»„1',
    images: [
      { w: 400.0, h: 84.4 },
      { w: 32.3, h: 320.0 },
      { w: 32.3, h: 320.0 },
      { w: 102.4, h: 140.0 },
      { w: 140.0, h: 102.4 },
    ],
  },
  {
    id: 2,
    name: 'å›¾ç»„2',
    images: [
      { w: 405.3, h: 200.0 },
      { w: 400.8, h: 200.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
      { w: 55.7, h: 50.0 },
    ],
  },
  {
    id: 3,
    name: 'å›¾ç»„3',
    images: [
      { w: 80.0, h: 33.8 },
      { w: 80.0, h: 33.8 },
      { w: 80.0, h: 33.7 },
      { w: 80.0, h: 33.7 },
      { w: 80.0, h: 33.7 },
      { w: 55.1, h: 55.0 },
      { w: 55.1, h: 55.0 },
    ],
  },
  {
    id: 4,
    name: 'å›¾ç»„4',
    images: [
      { w: 280.0, h: 149.7 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
      { w: 51.1, h: 45.0 },
    ],
  },
  {
    id: 5,
    name: 'å›¾ç»„5',
    images: [
      { w: 280.0, h: 28.7 },
      { w: 280.0, h: 28.7 },
      { w: 75.0, h: 50.2 },
      { w: 75.0, h: 50.2 },
      { w: 75.0, h: 50.2 },
      { w: 75.0, h: 50.2 },
      { w: 75.0, h: 50.2 },
      { w: 75.0, h: 50.2 },
    ],
  },
]

const CONTAINER_WIDTH = 600

// æ ¸å¿ƒç®—æ³•ï¼šå¤šç­–ç•¥å°è¯•ï¼Œé€‰æ‹©æœ€å°é«˜åº¦
function optimizeImageLayout(images, gap) {
  const n = images.length
  if (n === 0) return { totalHeight: 0, layout: [], rotations: [] }

  let bestResult = null
  let minHeight = Number.POSITIVE_INFINITY

  // ç­–ç•¥1ï¼šç©·ä¸¾æ—‹è½¬ç»„åˆ + Bottom-Leftç®—æ³•
  const rotationOptions = generateRotationOptions(images, gap)
  console.log(`ç”Ÿæˆäº† ${rotationOptions.length} ç§æ—‹è½¬ç»„åˆ`)
  
  for (let i = 0; i < rotationOptions.length; i++) {
    const rotations = rotationOptions[i]
    const result = packWithBottomLeft(images, rotations, gap)
    
    if (result && result.totalHeight < minHeight) {
      minHeight = result.totalHeight
      bestResult = result
      console.log(`æ‰¾åˆ°æ›´å¥½çš„å¸ƒå±€ï¼Œé«˜åº¦ï¼š${minHeight.toFixed(1)}pxï¼Œæ—‹è½¬ï¼š[${rotations.join(', ')}]`)
    }
  }

  // ç­–ç•¥2ï¼šç½‘æ ¼æ’åˆ—ç®—æ³•ï¼ˆå¤‡é€‰ï¼‰
  const gridResult = packWithGrid(images, gap)
  if (gridResult && gridResult.totalHeight < minHeight) {
    minHeight = gridResult.totalHeight
    bestResult = gridResult
    console.log(`ç½‘æ ¼ç®—æ³•æ›´ä¼˜ï¼Œé«˜åº¦ï¼š${minHeight.toFixed(1)}px`)
  }

  console.log(`æœ€ç»ˆé€‰æ‹©é«˜åº¦ï¼š${bestResult?.totalHeight?.toFixed(1)}px`)
  return bestResult || { totalHeight: Number.POSITIVE_INFINITY, layout: [], rotations: [] }
}

// ç”Ÿæˆæ—‹è½¬é€‰é¡¹ - ç¡®ä¿åŒ…å«æ‰€æœ‰æœ‰æ•ˆç»„åˆ
function generateRotationOptions(images, gap) {
  const options = []
  const n = images.length

  // ä¸ºå°æ•°é‡å›¾ç‰‡ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„æ—‹è½¬ç»„åˆ
  if (n <= 6) {
    const maxCombinations = Math.pow(2, n)
    
    for (let i = 0; i < maxCombinations; i++) {
      const rotation = []
      let valid = true
      
      for (let j = 0; j < n; j++) {
        const rotate = (i >> j) & 1
        rotation[j] = rotate === 1
        
        const width = rotation[j] ? images[j].h : images[j].w
        if (width > CONTAINER_WIDTH - gap) {
          valid = false
          break
        }
      }
      
      if (valid) {
        options.push(rotation)
        // è°ƒè¯•ï¼šè¾“å‡ºæ‰€æœ‰ç”Ÿæˆçš„ç»„åˆ
        if (n === 5) {
          console.log(`ç”Ÿæˆæ—‹è½¬ç»„åˆ: [${rotation.join(', ')}]`)
        }
      }
    }
  } else {
    // å¤§é‡å›¾ç‰‡æ—¶ä½¿ç”¨å¯å‘å¼æ–¹æ³•
    options.push(new Array(n).fill(false))
    
    const forceRotate = images.map(img => 
      img.w > CONTAINER_WIDTH - gap && img.h <= CONTAINER_WIDTH - gap
    )
    options.push(forceRotate)
    
    const ratioRotate = images.map(img => {
      if (img.w > CONTAINER_WIDTH - gap) return false
      if (img.h > CONTAINER_WIDTH - gap) return false
      const ratio = Math.max(img.w, img.h) / Math.min(img.w, img.h)
      return ratio > 3 && img.h > img.w
    })
    options.push(ratioRotate)
  }

  console.log(`æ€»å…±ç”Ÿæˆ ${options.length} ç§æœ‰æ•ˆæ—‹è½¬ç»„åˆ`)
  return options
}

// Bottom-Leftç®—æ³• - å¢åŠ è¯¦ç»†è°ƒè¯•
function packWithBottomLeft(images, rotations, gap) {
  const items = images.map((img, idx) => ({
    w: rotations[idx] ? img.h : img.w,
    h: rotations[idx] ? img.w : img.h,
    originalIndex: idx,
    rotated: rotations[idx],
    area: img.w * img.h
  })).filter(item => item.w <= CONTAINER_WIDTH - gap)

  // ç‰¹åˆ«æ·»åŠ ä¸€ä¸ªä¸“é—¨çš„"é«˜åº¦ä¼˜åŒ–"ç­–ç•¥
  const sortingStrategies = [
    // 0. é«˜åº¦æœ€å°åŒ–ç­–ç•¥ï¼šå®½çŸ©å½¢åœ¨åº•éƒ¨ï¼Œçª„æ¡åœ¨ä¸Šæ–¹å æ”¾
    (a, b) => {
      const aIsWideBase = a.w > 300 && a.h < 100  // ç±»ä¼¼400Ã—84çš„åº•åº§
      const bIsWideBase = b.w > 300 && b.h < 100
      const aIsHorizontalStrip = a.w > 200 && a.h < 50  // ç±»ä¼¼320Ã—32çš„æ¨ªæ¡
      const bIsHorizontalStrip = b.w > 200 && b.h < 50
      
      // å®½åº•åº§ä¼˜å…ˆ
      if (aIsWideBase && !bIsWideBase) return -1
      if (!aIsWideBase && bIsWideBase) return 1
      
      // ç„¶åæ˜¯ä¸­ç­‰æ–¹å½¢
      if (!aIsWideBase && !bIsWideBase && !aIsHorizontalStrip && !bIsHorizontalStrip) {
        return b.area - a.area
      }
      
      // æœ€åæ˜¯æ¨ªæ¡
      if (aIsHorizontalStrip && !bIsHorizontalStrip) return 1
      if (!aIsHorizontalStrip && bIsHorizontalStrip) return -1
      
      return a.h - b.h  // ç›¸åŒç±»å‹æŒ‰é«˜åº¦å‡åº
    },
    
    // 1. é¢ç§¯é™åºï¼ˆç»å…¸ç­–ç•¥ï¼‰
    (a, b) => b.area - a.area,
    
    // 2. å®½çŸ©å½¢ä¼˜å…ˆï¼Œç„¶åæŒ‰é¢ç§¯
    (a, b) => {
      const aWide = a.w > a.h * 1.5
      const bWide = b.w > b.h * 1.5
      if (aWide && !bWide) return -1
      if (!aWide && bWide) return 1
      return b.area - a.area
    },
    
    // 3. é«˜åº¦å‡åºï¼Œå®½åº¦é™åºï¼ˆå±‚æ¬¡åŒ–å¸ƒå±€ï¼‰
    (a, b) => a.h - b.h || b.w - a.w
  ]

  let bestLayout = null
  let bestHeight = Number.POSITIVE_INFINITY
  let bestStrategyIndex = -1

  for (let i = 0; i < sortingStrategies.length; i++) {
    const sortedItems = [...items].sort(sortingStrategies[i])
    const result = placeItemsBottomLeft(sortedItems, gap)
    
    if (result.totalHeight < bestHeight) {
      bestHeight = result.totalHeight
      bestLayout = { ...result, rotations }
      bestStrategyIndex = i
    }
  }

  // è°ƒè¯•è¾“å‡º
  if (images.length === 5 && rotations.some(r => r)) {  // åªå¯¹å›¾ç»„1ä¸”æœ‰æ—‹è½¬çš„æƒ…å†µè¾“å‡ºè°ƒè¯•ä¿¡æ¯
    console.log(`æ—‹è½¬ [${rotations.join(', ')}]: é«˜åº¦=${bestHeight.toFixed(1)}px, ç­–ç•¥=${bestStrategyIndex}`)
  }

  return bestLayout
}

// æ ¸å¿ƒè£…ç®±é€»è¾‘
function placeItemsBottomLeft(items, gap) {
  const placed = []

  for (const item of items) {
    const position = findBestPosition(placed, item, gap)
    if (position) {
      placed.push({
        x: position.x,
        y: position.y,
        width: item.w,
        height: item.h,
        originalIndex: item.originalIndex,
        rotated: item.rotated
      })
    }
  }

  const totalHeight = placed.length > 0 ? 
    Math.max(...placed.map(p => p.y + p.height)) + gap : gap

  return { totalHeight, layout: placed }
}

// å¯»æ‰¾æœ€ä½³ä½ç½® - å¢å¼ºç©ºéš™å¡«å……èƒ½åŠ›
function findBestPosition(placed, item, gap) {
  const candidates = []

  // åŸºæœ¬ä½ç½®
  candidates.push({ x: gap, y: gap })

  // æ ‡å‡†ä½ç½®ï¼šæ¯ä¸ªå·²æ”¾ç½®çŸ©å½¢çš„å³è¾¹å’Œä¸‹è¾¹
  for (const rect of placed) {
    candidates.push(
      { x: rect.x + rect.width + gap, y: rect.y },
      { x: rect.x, y: rect.y + rect.height + gap }
    )
  }

  // å¢å¼ºç©ºéš™æ£€æµ‹ï¼šæ£€æŸ¥æ˜¯å¦èƒ½å¡«å…¥æ›´ç´§å‡‘çš„ä½ç½®
  if (placed.length > 0) {
    // å¯»æ‰¾æ°´å¹³ç©ºéš™
    for (let y = gap; y <= 400; y += 10) { // æ‰«æä¸åŒé«˜åº¦
      let currentX = gap
      let canFit = true
      
      // æ£€æŸ¥è¿™ä¸ªé«˜åº¦æ˜¯å¦æœ‰è¶³å¤Ÿçš„è¿ç»­ç©ºé—´
      while (currentX + item.w <= CONTAINER_WIDTH && canFit) {
        const testPos = { x: currentX, y: y }
        if (!checkOverlap(testPos, item, placed)) {
          candidates.push(testPos)
          break
        }
        currentX += 10
        if (currentX > CONTAINER_WIDTH - item.w) {
          canFit = false
        }
      }
    }

    // ç‰¹æ®Šæ£€æµ‹ï¼šç¬¬ä¸€å±‚å³ä¾§ç©ºéš™
    const firstRowItems = placed.filter(p => p.y <= gap + 10)
    if (firstRowItems.length > 0) {
      const rightmostX = Math.max(...firstRowItems.map(p => p.x + p.width))
      const firstRowMaxHeight = Math.max(...firstRowItems.map(p => p.height))
      
      // ç¬¬ä¸€å±‚å³ä¾§ç©ºéš™
      if (rightmostX + gap + item.w <= CONTAINER_WIDTH) {
        candidates.push({
          x: rightmostX + gap,
          y: gap,
          priority: 'first-row-right'
        })
        
        // å¦‚æœç‰©å“æ¯”è¾ƒçŸ®ï¼Œä¹Ÿå¯ä»¥å°è¯•åœ¨ç¬¬ä¸€å±‚çš„ä¸åŒé«˜åº¦
        if (item.h < firstRowMaxHeight / 2) {
          for (let offsetY = 0; offsetY < firstRowMaxHeight - item.h; offsetY += item.h + gap) {
            candidates.push({
              x: rightmostX + gap,
              y: gap + offsetY,
              priority: 'first-row-stacked'
            })
          }
        }
      }
    }
  }

  // è¿‡æ»¤æœ‰æ•ˆä½ç½®
  const validPositions = candidates.filter(pos => {
    return pos.x + item.w <= CONTAINER_WIDTH &&
           !checkOverlap(pos, item, placed)
  })

  if (validPositions.length === 0) return null

  // é€‰æ‹©æœ€ä¼˜ä½ç½®ï¼šä¼˜å…ˆçº§ > æœ€å°Y > æœ€å°X
  return validPositions.reduce((best, pos) => {
    // æœ‰ç‰¹æ®Šä¼˜å…ˆçº§çš„ä½ç½®ä¼˜å…ˆ
    if (pos.priority && !best.priority) return pos
    if (!pos.priority && best.priority) return best
    
    // éƒ½æœ‰ä¼˜å…ˆçº§æˆ–éƒ½æ²¡æœ‰ä¼˜å…ˆçº§æ—¶ï¼Œæ¯”è¾ƒä½ç½®
    if (pos.y < best.y) return pos
    if (pos.y === best.y && pos.x < best.x) return pos
    return best
  })
}

// æ£€æŸ¥é‡å 
function checkOverlap(pos, item, placed) {
  const newRect = {
    x: pos.x,
    y: pos.y,
    width: item.w,
    height: item.h
  }

  return placed.some(rect => {
    return !(newRect.x + newRect.width <= rect.x ||
             rect.x + rect.width <= newRect.x ||
             newRect.y + newRect.height <= rect.y ||
             rect.y + rect.height <= newRect.y)
  })
}

// ç½‘æ ¼æ’åˆ—ç®—æ³•
function packWithGrid(images, gap) {
  const placed = []
  const rotations = new Array(images.length).fill(false)

  // æŒ‰é¢ç§¯æ’åº
  const sortedImages = images
    .map((img, idx) => ({ ...img, originalIndex: idx }))
    .sort((a, b) => (b.w * b.h) - (a.w * a.h))

  let currentY = gap
  let currentX = gap
  let rowHeight = 0

  for (const img of sortedImages) {
    let width = img.w
    let height = img.h
    let rotated = false

    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ—‹è½¬
    if (img.w > CONTAINER_WIDTH - gap && img.h <= CONTAINER_WIDTH - gap) {
      width = img.h
      height = img.w
      rotated = true
    }

    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢è¡Œ
    if (currentX + width > CONTAINER_WIDTH) {
      currentY += rowHeight + gap
      currentX = gap
      rowHeight = 0
    }

    placed.push({
      x: currentX,
      y: currentY,
      width: width,
      height: height,
      originalIndex: img.originalIndex,
      rotated: rotated
    })

    rotations[img.originalIndex] = rotated
    currentX += width + gap
    rowHeight = Math.max(rowHeight, height)
  }

  const totalHeight = currentY + rowHeight + gap

  return { totalHeight, layout: placed, rotations }
}

// æ¸²æŸ“å‡½æ•°
function renderResults(groups, gap) {
  const container = document.getElementById('resultsContainer')
  container.innerHTML = ''

  groups.forEach((group) => {
    const result = optimizeImageLayout(group.images, gap)

    const groupDiv = document.createElement('div')
    groupDiv.className = 'group-result'

    const rotatedCount = result.rotations.filter((r) => r).length
    const totalArea = result.layout.reduce((sum, item) => sum + item.width * item.height, 0)
    const containerArea = CONTAINER_WIDTH * result.totalHeight
    const efficiency = containerArea > 0 ? ((totalArea / containerArea) * 100).toFixed(1) : '0'

    groupDiv.innerHTML = `
        <div class="group-header">
            <h3>${group.name}</h3>
            <span>æ€»é«˜åº¦: ${result.totalHeight.toFixed(1)}px</span>
        </div>
        <div class="group-content">
            <div class="visualization" id="vis-${group.id}">
                <div class="container-boundary"></div>
            </div>
            <div class="stats">
                <div class="stat-row">
                    <span><strong>å›¾ç‰‡æ•°é‡:</strong></span>
                    <span>${group.images.length} å¼ </span>
                </div>
                <div class="stat-row">
                    <span><strong>æ—‹è½¬å›¾ç‰‡:</strong></span>
                    <span>${rotatedCount} å¼  (${result.rotations
                      .map((r, i) => (r ? i + 1 : ''))
                      .filter((i) => i)
                      .join(', ') || 'æ— '
                    })</span>
                </div>
                <div class="stat-row">
                    <span><strong>ç©ºé—´åˆ©ç”¨ç‡:</strong></span>
                    <span>${efficiency}%</span>
                </div>
                <div class="stat-row">
                    <span><strong>å®¹å™¨ä½¿ç”¨:</strong></span>
                    <span>600Ã—${result.totalHeight.toFixed(1)}px</span>
                </div>
            </div>
            <div class="algorithm-info">
                <strong>ç®€åŒ–å¤šç­–ç•¥ç®—æ³•:</strong> Bottom-Left + ç½‘æ ¼æ’åˆ—ï¼Œè‡ªåŠ¨é€‰æ‹©æœ€å°é«˜åº¦æ–¹æ¡ˆ
            </div>
        </div>
    `

    container.appendChild(groupDiv)
    renderImages(group, result, gap)
  })
}

function renderImages(group, result, gap) {
  const container = document.getElementById(`vis-${group.id}`)
  if (!container) return

  result.layout.forEach((item) => {
    const imgDiv = document.createElement('div')
    imgDiv.className = `image-item color-${item.originalIndex % 8}`
    imgDiv.style.left = `${item.x}px`
    imgDiv.style.top = `${item.y}px`
    imgDiv.style.width = `${item.width}px`
    imgDiv.style.height = `${item.height}px`

    const originalImg = group.images[item.originalIndex]
    imgDiv.title = `å›¾ç‰‡${item.originalIndex + 1}\nåŸå§‹: ${originalImg.w.toFixed(1)}Ã—${originalImg.h.toFixed(1)}\nå½“å‰: ${item.width.toFixed(1)}Ã—${item.height.toFixed(1)}\n${item.rotated ? 'å·²æ—‹è½¬90Â°' : 'æœªæ—‹è½¬'}`

    imgDiv.innerHTML = `
        <div class="image-number">${item.originalIndex + 1}</div>
        ${item.rotated ? '<div class="rotated-indicator">â†»</div>' : ''}
    `

    container.appendChild(imgDiv)
  })
}

function showLoading() {
  const loading = document.createElement('div')
  loading.className = 'loading'
  loading.innerHTML = `
    <div class="spinner"></div>
    <div>å¤šç­–ç•¥ç®—æ³•ä¼˜åŒ–ä¸­...</div>
  `
  loading.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column;
    justify-content: center; align-items: center; color: white;
    font-size: 20px; z-index: 1000;
  `
  
  const spinner = loading.querySelector('.spinner')
  if (spinner) {
    spinner.style.cssText = `
      width: 50px; height: 50px; border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%; border-top: 4px solid white;
      animation: spin 1s linear infinite; margin-bottom: 20px;
    `
  }
  
  document.body.appendChild(loading)
  return loading
}

async function optimize() {
  const gap = Number.parseInt(document.getElementById('gapInput').value) || 5
  const loading = showLoading()

  setTimeout(() => {
    renderResults(imageGroups, gap)
    document.body.removeChild(loading)

    console.log('=== å¤šç­–ç•¥ç®—æ³•ç»“æœ ===')
    imageGroups.forEach((group) => {
      const result = optimizeImageLayout(group.images, gap)
      console.log(`\n${group.name}:`)
      console.log(`æ€»é«˜åº¦: ${result.totalHeight.toFixed(1)}px`)
      console.log(`æ—‹è½¬é…ç½®: [${result.rotations.join(', ')}]`)
      const totalArea = group.images.reduce((sum, img) => sum + img.w * img.h, 0)
      const efficiency = ((totalArea / (CONTAINER_WIDTH * result.totalHeight)) * 100).toFixed(1)
      console.log(`ç©ºé—´åˆ©ç”¨ç‡: ${efficiency}%`)
    })
  }, 100)
}

document.getElementById('optimizeBtn').addEventListener('click', optimize)
window.addEventListener('load', optimize)
  </script>
</body>

</html>
